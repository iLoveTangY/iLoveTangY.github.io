<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png?v=6.5.0">










<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="这篇文章主要复习（学习）以下内容：  冒泡排序 选择排序 插入排序 master公式 归并排序 归并排序的应用 小和问题 逆序对问题   对数器  冒泡排序冒泡排序十分简单，大家应该都很熟悉。所谓冒泡，就是每次把数组中第0个和第1个元素比较，如果第0个比第1个大的话就交换两个元素的位置（a[0] &amp;gt; a[1] ? swap(a, 0, 1) : ;），否则不做操作；然后比较第1个和第2个，第">
<meta name="keywords" content="algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="算法复习（一）">
<meta property="og:url" content="http://yoursite.com/2018/12/05/算法复习（一）/index.html">
<meta property="og:site_name" content="EnochTang">
<meta property="og:description" content="这篇文章主要复习（学习）以下内容：  冒泡排序 选择排序 插入排序 master公式 归并排序 归并排序的应用 小和问题 逆序对问题   对数器  冒泡排序冒泡排序十分简单，大家应该都很熟悉。所谓冒泡，就是每次把数组中第0个和第1个元素比较，如果第0个比第1个大的话就交换两个元素的位置（a[0] &amp;gt; a[1] ? swap(a, 0, 1) : ;），否则不做操作；然后比较第1个和第2个，第">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-07T03:00:07.894Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法复习（一）">
<meta name="twitter:description" content="这篇文章主要复习（学习）以下内容：  冒泡排序 选择排序 插入排序 master公式 归并排序 归并排序的应用 小和问题 逆序对问题   对数器  冒泡排序冒泡排序十分简单，大家应该都很熟悉。所谓冒泡，就是每次把数组中第0个和第1个元素比较，如果第0个比第1个大的话就交换两个元素的位置（a[0] &amp;gt; a[1] ? swap(a, 0, 1) : ;），否则不做操作；然后比较第1个和第2个，第">






  <link rel="canonical" href="http://yoursite.com/2018/12/05/算法复习（一）/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>算法复习（一） | EnochTang</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EnochTang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>主页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/算法复习（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="EnochTang">
      <meta itemprop="description" content="个人小站">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EnochTang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法复习（一）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 20:23:38" itemprop="dateCreated datePublished" datetime="2018-12-05T20:23:38+08:00">2018-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-07 11:00:07" itemprop="dateModified" datetime="2018-12-07T11:00:07+08:00">2018-12-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这篇文章主要复习（学习）以下内容：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li><em>master</em>公式</li>
<li>归并排序</li>
<li>归并排序的应用<ul>
<li>小和问题</li>
<li>逆序对问题</li>
</ul>
</li>
<li>对数器</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序十分简单，大家应该都很熟悉。所谓冒泡，就是每次把数组中第0个和第1个元素比较，如果第0个比第1个大的话就交换两个元素的位置（<code>a[0] &gt; a[1] ? swap(a, 0, 1) : ;</code>），否则不做操作；然后比较第1个和第2个，第2个和第3个……一直到第n-2个和第n-1个。最后第n-1个就一定是整个数组中最大的元素。然后第二次循环的时候就只用比较到第n-2个了。整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = ivec.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz<span class="number">-1</span>; ++i)  <span class="comment">// 总共只需n-1次，排好n-1次后最后一个元素就不用排了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ivec[j] &gt; ivec[j+<span class="number">1</span>])</span><br><span class="line">                my_swap(ivec, j, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为$O(N^2)$。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的思想也很简单，就是每次都从未排序的元素里面找到一个最小的然后把它和第一个元素交换，这样一次下来第一个元素的位置就确定了。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = ivec.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min_index = i;  <span class="comment">// 当前这轮循环中最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; sz; ++j)</span><br><span class="line">            <span class="keyword">if</span> (ivec[j] &lt; ivec[min_index])</span><br><span class="line">                min_index = j;</span><br><span class="line">        <span class="keyword">if</span> (min_index != i)</span><br><span class="line">            my_swap(ivec, i, min_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为$O(N^2)$。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的思想和打扑克牌类似。你手上已有的牌是有序的，然后从牌堆里抽一张牌插入到你手上的牌的合适的位置。对数组排序的过程就是这样：首先，第1个元素已经有序了，然后看第2个元素；如果第二个元素比第1个小，交换它们，如果第2个比第1个大，则说明第2个的位置正确，不用交换；继续看第3个和第2个，如果第3个比第2个小，交换它们，否则继续下一个，然后继续看交换后的第2个是否比第1个小，如果小的话就交换，否则结束这一轮，进入下一个……代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = ivec.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; ivec[j] &gt;= ivec[j+<span class="number">1</span>]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            my_swap(ivec, j, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序的时间复杂度情况稍微复杂一些，最坏情况下，即数组完全是逆序时，时间复杂度为$O(N^2)$；最好情况下，即数组完全是有序时，时间复杂度为$O(N)$。我们统计复杂度时只考虑最坏情况，因此我们认为插入排序的时间复杂度为$O(N^2)$。</p>
<h1 id="master-公式"><a href="#master-公式" class="headerlink" title="master 公式"></a>master 公式</h1><p>在归并排序之前我们先介绍<em>master</em>公式。</p>
<blockquote>
<p>master公式（也称主方法）是用来利用分治策略来解决问题经常使用的时间复杂度的分析方法。</p>
</blockquote>
<p>具体如下：</p>
<p>如果你写出来的某个分治算法的计算量的公式有如下的形式：</p>
<script type="math/tex; mode=display">T(N)=a\times T(\frac{N}{b}) + T(N^d)</script><p>那么可以得到如下的时间复杂度：</p>
<script type="math/tex; mode=display">\begin{equation}
O=\left\{
\begin{array}{rcl}
O(N^{log_ba}) & & {d < log_ba}\\
O(N^d \times logN) & & {d = log_ba}\\
O(N^d) & & {d > log_ba}\\
\end{array} \right.\end{equation}</script><p>比如说，有某个算法的计算量为$T(N)=2 \times T(N/2) + 1$；那么有$d=0,a=2,b=2$，那么$log_ba=1$，有$d&lt;1$，那么时间复杂度为$O(N)=O(N^{log_22})$。这个公式对我们下面分析归并排序的时间复杂度很有用。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote>
<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
</blockquote>
<p>具体说来操作如下，先从中间将一个大数组分成两个部分，然后再将这两个小部分进行同样的切分操作，得到四个小数组，再对这四个小数组进行同样的操作，得到八个小数组……一直到每个小数组不能切分（长度为1）为止，那么这些长度为1的小数组肯定是有序的了；然后再将这些有序数组一一归并（merge），这样最后得到的就是一个有序的原数组了。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行真正的排序操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_process</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; help_vec(ivec.size());</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)</span><br><span class="line">        help_vec[i++] = ivec[p1] &lt;= ivec[p2] ? ivec[p1++] : ivec[p2++];</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)</span><br><span class="line">        help_vec[i++] = ivec[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)</span><br><span class="line">        help_vec[i++] = ivec[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= r; ++i)</span><br><span class="line">        ivec[i] = help_vec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    do_merge_sort(ivec, l, mid);</span><br><span class="line">    do_merge_sort(ivec, mid+<span class="number">1</span>, r);</span><br><span class="line">    merge_process(ivec, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    do_merge_sort(ivec, <span class="number">0</span>, ivec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序的计算量为$T(N)=2 \times T(N/2)+T(N)$，根据master公式，时间复杂度为$O(NlogN)$。</p>
<h1 id="归并排序的应用"><a href="#归并排序的应用" class="headerlink" title="归并排序的应用"></a>归并排序的应用</h1><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><blockquote>
<p>求小和问题：在随机元素，随机数组大小的数组中，找出左边比右边元素小的所有元素之和。</p>
</blockquote>
<p>例如：数组[4,2,5,1,7,3,6] 第一个元素4比2大，不算小和，5比4和2都大，那就是4+2=6；1比4和2和5都小，不算小和；7比前面的都大，那就是上次小和6+4+2+5+1=18；然后3前面比2和1大，那就是18+2+1=21；最后6比4、2、5、1、3都大，结果就是21+4+2+5+1+3=36。那么最后的结果就是36。</p>
<p>这个问题最直接粗暴的方法就是从第二个数开始，每一个数都求它左边比它小的数，然后加起来求和。但是这个时间复杂度为$O(N^2)$。利用归并排序，我们可以有一个复杂度为$O(NlogN)$的解法。</p>
<p>以上面的数组为例，当我们归并<code>[4]</code>和<code>[2]</code>时就能判断4不是2的小和，当我们归并<code>[2, 4]</code>和<code>[5]</code>的时候，就能能知道2和4都是5的小和；然后是右边，归并到<code>[1]</code>和<code>[7]</code>的时候，1是7的小和，归并<code>[3]</code>和<code>[6]</code>的时候，3是6的小和，归并<code>[1, 7]</code>和<code>[3, 6]</code>的时候，1是3和6的小和，1要累加两次，7不是小和；最后是归并<code>[2, 4, 5]</code>和<code>[1, 3, 6, 7]</code>的时候，2是3、6、7的小和，2要累加3次，4是6和7的小和，4要累加2次，5是6和7的小和，5要累加2次。因此，最后的小和就是$2+4+1+3+1\times2+2\times3+4\times2+5\times2=36$。</p>
<p>因此，我们只要对归并排序稍做修改即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_process</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; help_vec(ivec.size());</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">int</span> less_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ivec[p1] &lt; ivec[p2])</span><br><span class="line">            less_sum += ivec[p1] * (r - p2 + <span class="number">1</span>);	<span class="comment">// 计算小和</span></span><br><span class="line">        help_vec[i++] = ivec[p1] &lt;= ivec[p2] ? ivec[p1++] : ivec[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)</span><br><span class="line">        help_vec[i++] = ivec[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)</span><br><span class="line">        help_vec[i++] = ivec[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= r; ++i)</span><br><span class="line">        ivec[i] = help_vec[i];</span><br><span class="line">    <span class="keyword">return</span> less_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum_left = do_merge_sort(ivec, l, mid);</span><br><span class="line">    <span class="keyword">int</span> sum_right = do_merge_sort(ivec, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 最后的小和等于左边归并排序中产生的小和加上右边归并中产生的小和加上左右归并过程中产生的小和</span></span><br><span class="line">    <span class="keyword">return</span> sum_left + merge_process(ivec, l, mid, r) + sum_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_merge_sort(ivec, <span class="number">0</span>, ivec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h2><blockquote>
<p>逆序对问题。给一列数$a_1,a_2,…,a_n$，求它的逆序对数，即有多少个有序对$(i,j)$，使得i<j 但$="" a_i="">a_j $。</j></p>
</blockquote>
<p>和小和问题类似，在归并的过程中，我们也可以算出来逆序对：在归并的过程中，如果左边的元素大于右边的元素，那么可以确定，左边数组中剩余的所有元素都大于右边的元素。那么当前归并过程中产生的逆序对的个数就是$l_{end}-l_{cur}+1$。</p>
<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>对数器的基本概念如下</p>
<ol>
<li><p>有一个你想测试的算法a</p>
</li>
<li><p>实现一个绝对正确但复杂度高的算法b</p>
</li>
<li><p>实现一个随机样本产生器</p>
</li>
<li><p>实现比对算法a和b的方法</p>
</li>
<li><p>多次（100000+）比对a和b来验证a是否正确</p>
</li>
<li><p>如果有样本出错，则打印出来分析</p>
</li>
<li><p>当对此对比测试都正确时，可以基本判断算法a正确</p>
</li>
</ol>
<p>其中要注意的几点：</p>
<ul>
<li>要测试的算法a是时间复杂度比较低的算法，而算法b唯一要求就是保证正确，而不用管复杂度的高低</li>
<li>随机产生的样本大小要小，这里说的是样本的大小而不是样本的个数。因为出错时，小样本方便分析</li>
<li>随机产生的样本个数要多。 只有大量随机产生的样本才可能覆盖所有的情况</li>
<li>另外一点，算法b也无法保证完全的正确，在不断出错调试的过程中，也可以不断完善b，最终达到a和b都正确的完美结果</li>
</ul>
<p>例如，对上面的归并排序利用对数器验证正确的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = ivec[i];</span><br><span class="line">    ivec[i] = ivec[j];</span><br><span class="line">    ivec[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_process</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; help_vec(ivec.size());</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)</span><br><span class="line">        help_vec[i++] = ivec[p1] &lt;= ivec[p2] ? ivec[p1++] : ivec[p2++];</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)</span><br><span class="line">        help_vec[i++] = ivec[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)</span><br><span class="line">        help_vec[i++] = ivec[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= r; ++i)</span><br><span class="line">        ivec[i] = help_vec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    do_merge_sort(ivec, l, mid);</span><br><span class="line">    do_merge_sort(ivec, mid+<span class="number">1</span>, r);</span><br><span class="line">    merge_process(ivec, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    do_merge_sort(ivec, <span class="number">0</span>, ivec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机数组产生器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random_array_generator(<span class="keyword">unsigned</span> max_size, <span class="keyword">int</span> max_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u(<span class="number">1</span>, max_size);</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u_value(-max_value, max_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> sz = u(e);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">        vec.push_back(u_value(e));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec_1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec_2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ivec_1.size() != ivec_2.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivec_1.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (ivec_1[i] != ivec_2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_vector</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : ivec)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iter_size = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> max_size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> max_value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iter_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ivec_1 = random_array_generator(max_size, max_value);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec_2(ivec_1.begin(), ivec_1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec_3(ivec_1.begin(), ivec_1.end());   <span class="comment">// 拷贝一份数组</span></span><br><span class="line">        merge_sort(ivec_2);</span><br><span class="line">        sort(ivec_3.begin(), ivec_3.end());</span><br><span class="line">        <span class="keyword">if</span> (!is_equal(ivec_2, ivec_3))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector 1: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            print_vector(ivec_1);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector 2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            print_vector(ivec_2);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector 3: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            print_vector(ivec_3);</span><br><span class="line">            success = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (success ? <span class="string">"Ok"</span> : <span class="string">"Fucked"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其他的算法也是一样。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>左神算法初级课</li>
</ul>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/26/体验Windows Subsystem for Linux/" rel="next" title="安装配置Windows Subsystem for Linux">
                <i class="fa fa-chevron-left"></i> 安装配置Windows Subsystem for Linux
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/08/算法复习（二）/" rel="prev" title="算法复习（二）">
                算法复习（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="EnochTang">
            
              <p class="site-author-name" itemprop="name">EnochTang</p>
              <p class="site-description motion-element" itemprop="description">个人小站</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/iLoveTangY" title="GitHub &rarr; https://github.com/iLoveTangY" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/ytang007@163.com" title="E-Mail &rarr; ytang007@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#冒泡排序"><span class="nav-number">1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#选择排序"><span class="nav-number">2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#插入排序"><span class="nav-number">3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#master-公式"><span class="nav-number">4.</span> <span class="nav-text">master 公式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#归并排序"><span class="nav-number">5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#归并排序的应用"><span class="nav-number">6.</span> <span class="nav-text">归并排序的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#小和问题"><span class="nav-number">6.1.</span> <span class="nav-text">小和问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逆序对问题"><span class="nav-number">6.2.</span> <span class="nav-text">逆序对问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对数器"><span class="nav-number">7.</span> <span class="nav-text">对数器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EnochTang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
