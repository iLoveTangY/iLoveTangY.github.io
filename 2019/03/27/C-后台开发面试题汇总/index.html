<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png?v=6.5.0">










<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="C/C++ 语言基础C++变量内存布局首先是一个Linux进程的虚拟内存（参考自CSAPP）：  然后是典型的ELF可重定位目标文件（同样来自CSAPP）：  一个由C/C++编译的程序占用的内存分为以下几个部分：  栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由">
<meta name="keywords" content="C++,算法,操作系统,计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="C++后台开发面试题汇总">
<meta property="og:url" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/index.html">
<meta property="og:site_name" content="EnochTang">
<meta property="og:description" content="C/C++ 语言基础C++变量内存布局首先是一个Linux进程的虚拟内存（参考自CSAPP）：  然后是典型的ELF可重定位目标文件（同样来自CSAPP）：  一个由C/C++编译的程序占用的内存分为以下几个部分：  栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1554166314758.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1554166361103.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/合成默认构造函数与拷贝构造函数.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1555636607037.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1553737185069.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1553737633997.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1553737887469.png">
<meta property="og:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1553739179845.png">
<meta property="og:updated_time" content="2019-08-09T06:22:31.383Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++后台开发面试题汇总">
<meta name="twitter:description" content="C/C++ 语言基础C++变量内存布局首先是一个Linux进程的虚拟内存（参考自CSAPP）：  然后是典型的ELF可重定位目标文件（同样来自CSAPP）：  一个由C/C++编译的程序占用的内存分为以下几个部分：  栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由">
<meta name="twitter:image" content="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/1554166314758.png">






  <link rel="canonical" href="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>C++后台开发面试题汇总 | EnochTang</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EnochTang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>主页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/C-后台开发面试题汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="EnochTang">
      <meta itemprop="description" content="个人小站">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EnochTang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++后台开发面试题汇总
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-27 12:50:05" itemprop="dateCreated datePublished" datetime="2019-03-27T12:50:05+08:00">2019-03-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-09 14:22:31" itemprop="dateModified" datetime="2019-08-09T14:22:31+08:00">2019-08-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/27/C-后台开发面试题汇总/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/03/27/C-后台开发面试题汇总/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/27/C-后台开发面试题汇总/" class="leancloud_visitors" data-flag-title="C++后台开发面试题汇总">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="C-C-语言基础"><a href="#C-C-语言基础" class="headerlink" title="C/C++ 语言基础"></a>C/C++ 语言基础</h1><h2 id="C-变量内存布局"><a href="#C-变量内存布局" class="headerlink" title="C++变量内存布局"></a>C++变量内存布局</h2><p>首先是一个Linux进程的虚拟内存（参考自CSAPP）：</p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1554166314758.png" alt="1554166314758"></p>
<p>然后是典型的ELF可重定位目标文件（同样来自CSAPP）：</p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1554166361103.png" alt="1554166361103"></p>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p>
<ol>
<li>栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</li>
<li>全局区（静态区）（static）：在ELF可重定位目标文件中对应.bss和.data段。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li>
<li>文字常量区常量字符串就是放在这里的。在ELF中对应.rodata段。程序结束后由系统释放。</li>
<li>程序代码区—存放函数体的二进制代码。在ELF中对应.text段。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">int</span>   a   =   <span class="number">0</span>; <span class="comment">// 全局初始化区(.data段)</span></span><br><span class="line"><span class="keyword">char</span>   *p1;   <span class="comment">// 全局未初始化区(.bss段)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>   b;   <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span>   s[]   =   <span class="string">"abc"</span>;   <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span>   *p2;   <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span>   *p3   =   <span class="string">"123456"</span>;   <span class="comment">// "123456\0"在常量区，p3在栈上。</span></span><br><span class="line">    <span class="keyword">static</span>   <span class="keyword">int</span>   c   =<span class="number">0</span>；   <span class="comment">// 全局（静态）初始化区(.data)</span></span><br><span class="line">    p1   =   (<span class="keyword">char</span>   *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2   =   (<span class="keyword">char</span>   *)<span class="built_in">malloc</span>(<span class="number">20</span>);  <span class="comment">// 分配得来得10和20字节的区域就在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,   <span class="string">"123456"</span>);   <span class="comment">// "123456\0" 放在常量区，编译器可能会将它与p3所指向的"123456"  优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，并非所有的常量都会放在.rodata段。对于一个使用const修饰的常量，来说，如果它是全局变量，则会放入.rodata段，如果是局部变量，则只会让编译器利用const关键字来做检查，不会放入.rodata段中，只会放入栈中。</p>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a><code>static</code>关键字的作用</h2><ul>
<li><code>static</code>修饰变量<ul>
<li>用于局部变量中，成为静态局部变量.。静态局部变量有两个用法：记忆功能和全局生存期。</li>
<li>用于全局变量，主要作用是限制此全局变量被其他的文件调用。</li>
<li>用于类中的成员，表示这个成员是属于这个类但是不属于类的任意特定实例。</li>
</ul>
</li>
<li><code>static</code>修饰函数<ul>
<li>用于非成员函数，限制函数作用域，使该函数只能在当前文件中可见</li>
<li>用于成员函数，表示这个成员是属于这个类但是不属于类的任何特定实例</li>
</ul>
</li>
</ul>
<h2 id="四种cast转换"><a href="#四种cast转换" class="headerlink" title="四种cast转换"></a>四种<code>cast</code>转换</h2><ul>
<li><p><code>const_cast</code>：常量性移除（并没有真正去除）</p>
<p>变量本身的const属性是不能去除的，只能去除指针（或引用）的const属性。也就是说通过<code>const_cast</code>运算符，也只能将<code>const type *</code>转换为<code>type*</code>，将<code>const type&amp;</code>转换为<code>type&amp;</code>。但是对于本身定义时为<code>const</code>的类型，即使你去掉<code>const</code>性，在你操作这片内容时候也要小心，只能r不能w操作，否则还是会出错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *d = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">char</span> *c = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(d);</span><br><span class="line">*c = <span class="string">'l'</span>;  <span class="comment">// 编译时正确，运行时出错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dynamic_cast</code>：向下安全转型</p>
<p>主要应用于<strong>继承体系</strong>, 可以由 “<strong>指向派生类的基类部分的指针</strong>“, 转换”<strong>指向派生类</strong>“或”<strong>指向兄弟类</strong>“;<code>static_cast</code><strong>只能</strong>转换为”指向派生类”；必须存在虚函数才能做<code>dynamic_cast</code>。</p>
</li>
<li><p><code>reinterpret_cast</code>：重新解释转型</p>
<p>主要用于对于类型指针类型的强制转化，<code>some_type*</code> -&gt; <code>special_type*</code>这样转化，类型信息可以是不完全的。它<strong>允许将任意指针转化到其他类型指针</strong>（弥补了<code>static_cast</code>的缺陷），也允许任意整数类型到任意指针类型转化(BT)。这样导致的结果是极其不安全的，不能安全的应用于其他目的，除非转化到原来类型。</p>
<p><code>reinterpret_cast</code>通常为操作数的位模式提供较低层的重新解释。</p>
</li>
<li><p><code>static_cast</code>：静态转型</p>
<ul>
<li><p>用于所有系统类型之间转化，但是不能用于系统指针类型的转化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;d;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pd);  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用于继承类之间的转化（含指针），不能用于其他没有隐式转化的对象类型之间的转化。</p>
<p>进行上行转换（把子类的指针或引用转换成基类表示）是安全的，进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rA</span> &#123;</span> <span class="keyword">int</span> m_a; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rB</span> &#123;</span> <span class="keyword">int</span> m_b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rC</span> :</span> <span class="keyword">public</span> rA, <span class="keyword">public</span> rB &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CastReinterpret</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *i= <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*i = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*i = "</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">double</span> *d=<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt; (i);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*d = "</span> &lt;&lt; *d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d = "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	rC c;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;c = "</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reinterpret_cast&lt;rB*&gt;(&amp;c) = "</span> &lt;&lt;<span class="keyword">reinterpret_cast</span>&lt;rB*&gt;(&amp;c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"static_cast &lt;rB*&gt;(&amp;c) = "</span> &lt;&lt; <span class="keyword">static_cast</span> &lt;rB*&gt;(&amp;c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reinterpret_cast&lt;rA*&gt;(&amp;c) = "</span> &lt;&lt;<span class="keyword">reinterpret_cast</span>&lt;rA*&gt;(&amp;c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"static_cast &lt;rA*&gt;(&amp;c) = "</span> &lt;&lt; <span class="keyword">static_cast</span> &lt;rA*&gt;(&amp;c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CastReinterpret();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/合成默认构造函数与拷贝构造函数.png" alt="合成默认构造函数与拷贝构造函数"></p>
<p>注意，<code>reinterpret_cast</code>转型之后对象的地址是不会变的，而使用<code>static_cast</code>转型后对象的地址可能发生了改变，这是多个基类在子类中的地址不同导致的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="指针与引用的区别与联系"><a href="#指针与引用的区别与联系" class="headerlink" title="指针与引用的区别与联系"></a>指针与引用的区别与联系</h2><p><strong>相同点</strong>：</p>
<ol>
<li>都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</li>
</ol>
<p><strong>不同点</strong>：</p>
<ul>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。</li>
<li>引用没有<code>const</code>，指针有<code>const</code>，<code>const</code>的指针不可变；具体指没有<code>int&amp; const a</code>这种形式，而<code>const int&amp; a</code>是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。</li>
<li>引用是类型安全的，而指针不是 (引用比指针多了类型检查）</li>
<li>在模板编程中，如果定义一个指向模板类型的指针，模板不会具现化，但是如果定义一个模板类型的引用，模板会被具现化。</li>
</ul>
<h2 id="C-11的三种智能指针"><a href="#C-11的三种智能指针" class="headerlink" title="C++ 11的三种智能指针"></a>C++ 11的三种智能指针</h2><p>C++11之后智能指针分为了三种：<code>shared_ptr</code>, <code>unique_ptr</code>, <code>weak_ptr</code> 。而<code>weak_ptr</code>相当于<code>shared_ptr</code>的一个辅助指针, 所以正式的智能指针只有<code>shared_ptr</code>和<code>unique_ptr</code>。</p>
<ul>
<li><code>shared_ptr</code>提供引用计数，当引用计数为0时会自动销毁所管理的对象，不用担心内存泄漏，但是在使用时要注意避免循环引用的问题；</li>
<li><code>unique_ptr</code><strong>拥有</strong>所管理的对象，禁止赋值，但是<strong>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做</strong>。</li>
<li><code>weak_ptr</code>可以辅助<code>shared_ptr</code>，使用<code>weak_ptr</code>指向一个对象不增加<code>shared_ptr</code>的引用计数。</li>
</ul>
<p><code>shared_ptr</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">    <span class="keyword">int</span> *_ref_count;  <span class="comment">// 引用计数,必须new出来，不能是成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    my_shared_ptr() : _ptr(<span class="literal">nullptr</span>), _ref_count(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，若用一个普通指针初始化两个智能指针会出现循环引用的问题，可能会重复释放</span></span><br><span class="line">    my_shared_ptr(T *obj) : _ptr(obj), _ref_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数，引用计数器加一，并指向同一块内存区域</span></span><br><span class="line">    my_shared_ptr(my_shared_ptr &amp;rhs) : _ptr(rhs._ptr), _ref_count(&amp;(++*rhs._ref_count))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制运算符</span></span><br><span class="line">    my_shared_ptr&amp; <span class="keyword">operator</span>=(my_shared_ptr &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)  <span class="comment">// 处理自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        ++*rhs._ref_count;  <span class="comment">// rhs引用计数加1</span></span><br><span class="line">        <span class="keyword">if</span> (--*_ref_count == <span class="number">0</span>)  <span class="comment">// 自己引用计数减1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _ref_count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ptr = rhs._ptr;</span><br><span class="line">        _ref_count = rhs._ref_count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针运算符</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ref_count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~my_shared_ptr() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr &amp;&amp; --*_ref_count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _ref_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code>的线程安全性分析见<a href="https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html" target="_blank" rel="noopener">这里</a>。总结来说就是<code>shared_ptr</code>的引用计数是线程安全的，因此多个线程同时读是线程安全的，比如<code>g</code>是一个<code>shared_ptr</code>，那么<code>x = g</code>和<code>y = g</code>是线程安全的，但是多线程写或者一个线程读，一个线程写是不安全的，需要加锁。</p>
<h2 id="C-里map和set为什么采用红黑树不采用AVL-Tree？"><a href="#C-里map和set为什么采用红黑树不采用AVL-Tree？" class="headerlink" title="C++ 里map和set为什么采用红黑树不采用AVL Tree？"></a>C++ 里<code>map</code>和<code>set</code>为什么采用红黑树不采用AVL Tree？</h2><p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的reblance，导致效率下降<br>红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转</p>
<h2 id="C-面向对象三大特性"><a href="#C-面向对象三大特性" class="headerlink" title="C++ 面向对象三大特性"></a>C++ 面向对象三大特性</h2><ul>
<li><p>封装：封装是在设计类的一个基本原理，是将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与对数据进行的操作进行有机的结合，形成“类”，其中数据和函数都是类的成员。</p>
</li>
<li><p>继承：如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类”。继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</p>
<ol>
<li><p>访问权限</p>
<ul>
<li><code>public</code>： 父类对象内部、父类对象外部、子类对象内部、子类对象外部都可以访问。</li>
<li><code>protected</code>:父类对象内部、子类对象内部可以访问，父类对象外部、子类对象外部都不可访问。</li>
<li><code>private</code>：父类对象内部可以访问，其他都不可以访问。</li>
</ul>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1555636607037.png" alt="1555636607037"></p>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>继承方式<br>三种继承方式不影响子类对父类的访问权限，子类对父类只看父类的访问控制权。继承方式是为了控制子类(也称派生类)的调用方(也叫用户)对父类(也称基类)的访问权限。<code>public</code>、<code>protected</code>、<code>private</code>三种继承方式，相当于把父类的<code>public</code>访问权限在子类中变成了对应的权限。 如<code>protected</code>继承，把父类中的<code>public</code>成员在本类中变成了<code>protected</code>的访问控制权限；<code>private</code>继承，把父类的<code>public</code>成员和<code>protected</code>成员在本类中变成了<code>private</code>访问控制权。</p>
<p>ps.友元是类级别的，不存在继承的问题。</p>
</li>
</ol>
<ul>
<li><p>多态：多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。</p>
<ol>
<li><p>静态多态：静态多态也称为静态绑定或早绑定。编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。</p>
<ul>
<li><p>函数重载</p>
<p>编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定）。</p>
</li>
<li><p>泛型编程</p>
<p>泛型编程就是指编写独立于特定类型的代码，泛型在C++中的主要实现为模板函数和模板类。<br>泛型的特性：</p>
<ol>
<li>函数模板并不是真正的函数，它只是C++编译生成具体函数的一个模子。</li>
<li>函数模板本身并不生成函数，实际生成的函数是替换函数模板的那个函数，比如上例中的add(sum1,sum2)，这种替换是编译期就绑定的。</li>
<li>函数模板不是只编译一份满足多重需要，而是为每一种替换它的函数编译一份。</li>
<li>函数模板不允许自动类型转换。</li>
<li>函数模板不可以设置默认模板实参。比如<code>template &lt;typename T=0&gt;</code>不可以。</li>
</ol>
</li>
</ul>
</li>
<li><p>动态多态<br>c++的动态多态是基于虚函数的。对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。</p>
</li>
<li><p>宏多态（？）<br>带变量的宏可以实现一种初级形式的静态多态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义泛化记号：宏ADD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(A, B) (A) + (B);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int i1(1), i2(2);</span><br><span class="line">    std::string s1("Hello, "), s2("world!");</span><br><span class="line">    <span class="keyword">int</span> i = ADD(i1, i2);                        <span class="comment">// 两个整数相加</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = ADD(s1, s2);                <span class="comment">// 两个字符串“相加”</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">"/n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s = "</span> &lt;&lt; s &lt;&lt; <span class="string">"/n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态多态和静态多态的比较</p>
<ol>
<li>静态多态<ul>
<li>优点：<ol>
<li>由于静多态是在编译期完成的，因此效率较高，编译器也可以进行优化；</li>
<li>有很强的适配性和松耦合性，比如可以通过偏特化、全特化来处理特殊类型；</li>
<li>最重要一点是静态多态通过模板编程为C++带来了泛型设计的概念，比如强大的STL库。</li>
</ol>
</li>
<li>缺点：<ol>
<li>由于是模板来实现静态多态，因此模板的不足也就是静多态的劣势，比如调试困难、编译耗时、代码膨胀、编译器支持的兼容性不能够处理异质对象集合</li>
</ol>
</li>
</ul>
</li>
<li>动态多态<ul>
<li>优点：<ol>
<li>OO设计，对是客观世界的直觉认识；</li>
<li>实现与接口分离，可复用</li>
<li>处理同一继承体系下异质对象集合的强大威力</li>
</ol>
</li>
<li>缺点：<ol>
<li>运行期绑定，导致一定程度的运行时开销；</li>
<li>编译器无法对虚函数进行优化</li>
<li>笨重的类继承体系，对接口的修改影响整个类层次；</li>
</ol>
</li>
</ul>
</li>
<li>不同点：<ul>
<li>本质不同，<code>早晚绑定</code>。静态多态在编译期决定，由模板具现完成，而动态多态在运行期决定，由继承、虚函数实现；</li>
<li>动态多态中接口是显式的，以<code>函数签名</code>为中心，多态通过虚函数在运行期实现，静态多台中接口是隐式的，以<code>有效表达式</code>为中心，多态通过模板具现在编译期完成</li>
</ul>
</li>
<li>相同点：<ul>
<li>都能够实现多态性，静态多态/编译期多态、动态多态/运行期多态；</li>
<li>都能够使接口和实现相分离，一个是模板定义接口，类型参数定义实现，一个是基类虚函数定义接口，继承类负责实现；</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><ul>
<li><p>概述  </p>
<p>它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被称为“虚”函数。<br>虚函数只能借助于指针或者引用来达到多态的效果。常用的方式是父类指针指向子类对象。当有多个对于父类的继承时，可以统一用父类指针来表示各子类对象，但是事实上所指向的对象具体是哪一个，或者说所调用的函数是哪一个子类的对象的函数需要在运行时才知道。这就实现了多态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"A::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"B::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;foo();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>语法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>=<span class="number">0</span> <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>  <span class="comment">// 虚函数</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>纯虚函数<br>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。含有虚函数的类成为抽象类，不能生成对象。<strong>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部</strong>，纯虚函数的函数体对于使用的确是没有意义，但是可以为子类实现这个纯虚函数提供实现参考。</p>
</li>
<li>虚函数表<br>虚表是属于类的，而不是属于某个具体的对象，<strong>一个类只需要一个虚表即可</strong> 。同一个类的所有对象都使用同一个虚表。为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>*__vptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</li>
</ul>
<h2 id="const关键字的作用"><a href="#const关键字的作用" class="headerlink" title="const关键字的作用"></a><code>const</code>关键字的作用</h2><ul>
<li><p><code>const</code>修饰变量</p>
<p><code>const</code>修饰符可以把对象转变为常量，意思就是说利用<code>const</code>进行修饰的变量的值在程序的任意位置将不能被修改，任何直接修改该变量的尝试都会导致编译错误。<code>const</code>对象默认为文件的局部变量，如果想要在文件外访问的话必须指定<code>const</code>变量为<code>extern</code>。<code>const</code>修饰指针时有顶层<code>const</code>和底层<code>const</code>之分。底层<code>const</code>即为指向常量的指针，例如：<code>const int * pi;</code>顶层<code>const</code>即为指针常量，表示指针本身不可修改，例如<code>int * const pi;</code>。</p>
</li>
<li><p><code>const</code>修饰函数</p>
<p><code>const</code>加在成员函数的声明后表示该函数不会修改类的任何数据成员。函数可以有<code>const</code>重载。</p>
</li>
</ul>
<h2 id="函数指针和函数对象的区别"><a href="#函数指针和函数对象的区别" class="headerlink" title="函数指针和函数对象的区别"></a>函数指针和函数对象的区别</h2><p>函数指针实际上就是一个普通的指针而已，只不过它指向的是一个函数，而函数对象本质上是一个类，只是重载了函数调用运算符。另外函数对象可以存储状态，所以比普通函数更加灵活。</p>
<h2 id="memcpy和memmove的区别以及实现，strncpy的实现"><a href="#memcpy和memmove的区别以及实现，strncpy的实现" class="headerlink" title="memcpy和memmove的区别以及实现，strncpy的实现"></a><code>memcpy</code>和<code>memmove</code>的区别以及实现，<code>strncpy</code>的实现</h2><p><code>void *memmove( void* dest, const void* src, size_t count );</code></p>
<p><code>void* memcpy(void* dest, void* src,size_t n)</code></p>
<p><code>memcpy</code>是内存拷贝函数，<code>memmove</code>函数则是内存移动函数，这两个函数的作用差不多，但是区别就在于<code>memmove</code>函数能够反向拷贝，不用在意<code>memcpy</code>函数会遇到的问题。也就说<code>memmove</code>能够处理<code>dest</code>和<code>src</code>有重叠的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dest);</span><br><span class="line">    assert(src);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str1 = (<span class="keyword">const</span> <span class="keyword">char</span> *)src;</span><br><span class="line">    <span class="keyword">char</span> *str2 = (<span class="keyword">char</span> *)dest;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        *str2++ = *str1++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dest);</span><br><span class="line">    assert(src);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *psrc = (<span class="keyword">const</span> <span class="keyword">char</span> *)src;</span><br><span class="line">    <span class="keyword">char</span> *pdest = (<span class="keyword">char</span> *)dest;</span><br><span class="line">    <span class="keyword">if</span> (pdest &gt; psrc &amp;&amp; pdest &lt; psrc + n)  <span class="comment">// 有重叠的情况从后往前复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            *(pdest+n) = *(psrc+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            *pdest++ = *psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>  *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    <span class="keyword">char</span> *cp = dest;</span><br><span class="line">    <span class="keyword">while</span> (n &amp;&amp; (*cp++ = *str++) != <span class="string">'\0'</span>)</span><br><span class="line">        --n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        *cp++ = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何限制一个类对象只在栈（堆）上分配空间？"><a href="#如何限制一个类对象只在栈（堆）上分配空间？" class="headerlink" title="如何限制一个类对象只在栈（堆）上分配空间？"></a>如何限制一个类对象只在栈（堆）上分配空间？</h2><p>参考<a href="&lt;https://blog.csdn.net/hxz_qlh/article/details/13135433&gt;">这里</a>。</p>
<h2 id="C-实现单例模式"><a href="#C-实现单例模式" class="headerlink" title="C++实现单例模式"></a>C++实现单例模式</h2><p>在单例模式中，不能通过构造函数来构造，因此要将构造函数设置为私有的或者删除的，另外还需要保证只能产生一个实例。</p>
<p>如果是单线程的情况下，单例模式实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton *local_instance_;</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    ~Singleton() &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义删除的拷贝赋值和拷贝构造函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (local_instance_ == <span class="literal">nullptr</span>)  <span class="comment">// 如果一个线程执行了这句之后被切出，另一个线程执行了下面的语句，那么就会产生出两个实例</span></span><br><span class="line">            local_instance_ = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> local_instance_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::local_instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>很明显，多线程情况下会出现Race Condition。还有，<code>local_instance_</code>会产生内存泄漏，但在一般情况下这不重要，因为程序结束了就自然会释放了。</p>
<p>为了解决这个问题，我们首先想到的就是加锁，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton *local_instance_;</span><br><span class="line">    <span class="keyword">static</span> MutexLock mutex_;</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    ~Singleton() &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义删除的拷贝赋值和拷贝构造函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(local_instance_ == <span class="literal">nullptr</span>)</span>  <span class="comment">// 如果一个线程执行了这句之后被切出，另一个线程执行了下面的语句，那么就会产生处两个实例</span></span></span><br><span class="line"><span class="function">            local_instance_ </span>= <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> local_instance_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::local_instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>这样，我们想要的效果是达到了，但是由于锁的存在，又出现了效率不高的问题。于是，就有大佬想出了DoubleCheck的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton *local_instance_;</span><br><span class="line">    <span class="keyword">static</span> MutexLock mutex_;</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    ~Singleton() &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义删除的拷贝赋值和拷贝构造函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (local_instance_ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(local_instance_ == <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">                local_instance_ </span>= <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> local_instance_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::local_instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>这样就大大减少了加锁的时间，不用每次都加锁。在很长的一段时间内这种方式都认为是正确的。但是在2004年，有人在<a href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf" target="_blank" rel="noopener">这篇文章</a>中提出了这种方法的问题：问题在于<code>local_instance_ = new Singleton();</code>这句话并不是原子操作，主要包含两个操作——分配内存空间、使变量指向内存。由于处理器的乱序执行，这两个操作并不能确定实际的先后顺序，假如线程A已经让<code>local_instance_</code>变量指向了内存，但是并没有实际分配内存空间，此时切换到线程B执行，B检测到<code>local_instance_</code>并不为<code>nullptr</code>，就将其返回使用，此时使用的是未分配的内存空间，这样就出现了问题。</p>
<p>C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。在C++11标准下，《Effective C++》提出了一种更优雅的单例模式实现，使用函数内的 local static 对象。这样，只有当第一次访问<code>get_instance()</code>方法时才创建实例。这种方法也被称为Meyers’ Singleton。C++0x之后该实现是线程安全的，C++0x之前仍需加锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    ~Singleton() &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义删除的拷贝赋值和拷贝构造函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::local_instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生<strong>内存泄露</strong>问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。</p>
<p>而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。</p>
<h2 id="常量指针与指针常量"><a href="#常量指针与指针常量" class="headerlink" title="常量指针与指针常量"></a>常量指针与指针常量</h2><ul>
<li><p>常量指针：指向常量的指针变量成为常量指针，本质是一个指针，指向的数据是一个常量，不能通过这个指针来修改指向的数据，但是可以指向不同的数据，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">cosnt <span class="keyword">int</span> *p = &amp;a;  <span class="comment">// 常量指针，指向的是常量，但是a不一定是常量，只是p认为自己指向的是一个常量</span></span><br><span class="line">*p = <span class="number">9</span>;  <span class="comment">// error</span></span><br><span class="line">p = &amp;b;  <span class="comment">// ok，可以指向不同的数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针常量：指针常量指自己本身是常量的数据，指向的不是常量。指针常量指向一个地址后不能再修改，也就是不能再指向别的数据，但是可以通过指针常量来修改指向的数据，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;  <span class="comment">// 指针常量</span></span><br><span class="line">*p = <span class="number">9</span>;  <span class="comment">// ok</span></span><br><span class="line">p = &amp;b;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p><code>C++</code>中所有的值都必然属于左值、右值二者之一。左值是指表达式结束后依然存在的<em>持久化对象</em>，右值是指表达式结束时就不再存在的<em>临时对象</em>。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：<strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong>。右值引用就是指向右值的引用，比如：<code>int  &amp;&amp;a = 1;</code> <code>a</code>就是一个右值引用，但是<code>a</code>本身是一个左值。</p>
<h2 id="C-有虚函数时类对象内存布局"><a href="#C-有虚函数时类对象内存布局" class="headerlink" title="C++有虚函数时类对象内存布局"></a>C++有虚函数时类对象内存布局</h2><p><a href="https://blog.csdn.net/haoel/article/details/1948051/" target="_blank" rel="noopener">看这里</a>。</p>
<h2 id="一个C-程序执行main函数前和执行完main函数后会发生什么"><a href="#一个C-程序执行main函数前和执行完main函数后会发生什么" class="headerlink" title="一个C++程序执行main函数前和执行完main函数后会发生什么"></a>一个C++程序执行main函数前和执行完main函数后会发生什么</h2><p>main函数执行前：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态和全局变量，即data段的内容</li>
<li>将main函数的参数argc, argv传递给main函数</li>
<li>运行main函数</li>
</ul>
<p>main函数执行之后：</p>
<ul>
<li>执行全局和静态变量的析构函数</li>
<li>执行用户使用<code>atexit()</code>注册的函数</li>
<li>释放内存</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h2><p><a href="[http://imty.site/2019/07/29/TCP%E8%AF%A6%E8%A7%A3/#more](http://imty.site/2019/07/29/TCP详解/#more">看这里</a>)。</p>
<h2 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h2><p>SYN Flood攻击是一种典型的拒绝服务型（Denial of Service）攻击。所谓拒绝服务型攻击就是通过进行攻击，使受害主机或网络不能够良好的提供服务，从而间接达到攻击的目的。</p>
<p>SYN Flood攻击利用的是IPv4中TCP协议的三次握手（Three-Way Handshake）过程进行的攻击。TCP协议规定，一端向另一端发起TCP连接时，它需要首先发送SYN 包到对方，对方收到后发送一个SYN+ACK包回来，发起方再发送 ACK包回去，这样三次握手就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCP Client）”，TCP连接的接收方叫作”TCP服务器（TCP Server）”。值得注意的是在TCP服务器收到TCP SYN request包时，在发送TCP SYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半开连接（Half-open Connection）。</p>
<p>在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCP SYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP服务器系统造成很大的系统负担，最终导致系统不能正常工作。</p>
<p>SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。</p>
<h2 id="TCP和UDP的区别及应用场景"><a href="#TCP和UDP的区别及应用场景" class="headerlink" title="TCP和UDP的区别及应用场景"></a>TCP和UDP的区别及应用场景</h2><ul>
<li>区别<ol>
<li>面向连接VS无连接<br>TCP建立一个连接需要3次握手IP数据包，断开连接需要4次握手。另外断开连接时发起方可能进入TIME_WAIT状态长达数分钟（视系统设置，windows一般为120秒），在此状态下连接（端口）无法被释放。<br>UDP不需要建立连接，可以直接发起。</li>
<li>可靠VS不可靠<br>TCP利用握手、ACK和重传机制，udp没有。<br>1，校验和（校验数据是否损坏）；<br>2，定时器（分组丢失则重传）；<br>3，序列号（用于检测丢失的分组和重复的分组）；<br>4，确认应答ACK（接收方告知发送方正确接收分组以及期望的下一个分组）；<br>5，否定确认（接收方通知发送方未被正确接收的分组）；<br>6，窗口和流水线（用于增加信道的吞吐量）。（窗口大小：无需等待确认应答而可以继续发送数据的最大值）</li>
<li>有序性<br>TCP利用seq序列号对包进行排序，udp没有。</li>
<li>面向字节流vs面向报文<ul>
<li>面向报文<br>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。（一个upd的最大报文长度$2^{16}-1-20-8$,20是ip报文头，8是udp报文头）</li>
<li>面向字节流<br>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
</ul>
</li>
<li>tcp有流量控制，udp没有</li>
<li>tcp的头部20 bytes，udp 8 bytes</li>
</ol>
</li>
<li>TCP应用场景：<br>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
<li>UDP应用场景：<br>效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
<h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq/ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<h2 id="http协议1-0-1-1-和-2有什么异同？"><a href="#http协议1-0-1-1-和-2有什么异同？" class="headerlink" title="http协议1.0 1.1 和 2有什么异同？"></a>http协议1.0 1.1 和 2有什么异同？</h2><p>http1.0和1.1的区别主要体现在以下部分：</p>
<ul>
<li><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ul>
<p>HTTP2与之前版本的区别：</p>
<ul>
<li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP/2的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>header压缩</strong>，HTTP/1.x的header带有大量信息，而且每次都要重复发送，HTTP/2使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
</ul>
<h2 id="使用http协议请求文件中的某一段该如何处理，请求的偏移量超过了文件大小会返回什么"><a href="#使用http协议请求文件中的某一段该如何处理，请求的偏移量超过了文件大小会返回什么" class="headerlink" title="使用http协议请求文件中的某一段该如何处理，请求的偏移量超过了文件大小会返回什么"></a>使用http协议请求文件中的某一段该如何处理，请求的偏移量超过了文件大小会返回什么</h2><p>可以采用Http中的Range首部来指定请求文件中的哪一段。如果成功，会返回206（Partial Content），如果失败416（Requested Range Not Satisfiable）状态码。如果服务器不支持，则返回200 Ok。</p>
<h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><h2 id="ip包在路由器的传播过程"><a href="#ip包在路由器的传播过程" class="headerlink" title="ip包在路由器的传播过程"></a>ip包在路由器的传播过程</h2><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>地址解析（ARP）协议，是用来在IPv4地址和各种网络技术使用的硬件地址之间进行转换的协议。地址解析是发现两个地址之间映射关系的过程。ARP提供从网络层地址到硬件地址的动态映射。</p>
<p>当我们使用Internet服务时，例如在浏览器中打开一个网页，本地计算机必须确定如何与相关的服务器联系。它首先判断该服务器是位于本地（同一IP子网的一部分）还是远程。如果是远程的，需要一台可达目的地址的路由器。仅在到达位于同一IP子网的系统时，ARP才能工作。</p>
<p>ARP工作的流程：</p>
<ol>
<li>首先，会查看本地的ARP缓存中是否已经有了对应的IP地址与硬件地址的映射关系，如果有，则可以直接使用；</li>
<li>如果ARP缓存中不存在对应的条目或者条目过期，那么ARP会向子网内所有主机发送一个ARP请求的链路层广播，寻找其他主机是否知道IP地址对应的硬件地址；</li>
<li>如果某个系统使用请求中指明的IP地址，则会发送一个ARP应答。这个ARP应答包含IP地址与对应的MAC地址。这个应答通常不是广播，而是直接发送给请求的发送方。</li>
<li>ARP应答被原始请的发送方接收，现在就可以发送引起这次ARP请求的那个数据包了。</li>
</ol>
<h2 id="TCP黏包问题"><a href="#TCP黏包问题" class="headerlink" title="TCP黏包问题"></a>TCP黏包问题</h2><p>黏包有两种：</p>
<p>一种是因为发送数据包时，每次发送的包小，因为系统进行优化算法（Nagle算法），就将两次的包放在一起发送，减少了资源的重复占用。多次发送会经历多次网络延迟，一起发送会减少网络延迟的次数。因此在发送小数据时会将两次数据一起发送，而客户端接收时，则会一并接收。即出现多次send会出现黏包。</p>
<p>第二种是因为接收数据时，有多次接收，第一次接收的数据量小，导致数据还没接收完，就停下了，剩余的数据会缓存在内存中，然后等到下次接收时和下一波数据一起接收。</p>
<h2 id="https与http"><a href="#https与http" class="headerlink" title="https与http"></a>https与http</h2><h2 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h2><p>详情参考<a href="https://segmentfault.com/a/1190000018129846" target="_blank" rel="noopener">这里</a>。</p>
<p>总结来说就是这样：</p>
<p>从Http标准上来说，GET和POST的区别如下：</p>
<ul>
<li>GET用于获取信息，是幂等的，且可缓存</li>
<li>POST用于修改服务器上的数据，非幂等，不可缓存</li>
</ul>
<p>但是从报文的角度来说，GET和POST没有实质性的区别，只是报文格式不同而已。GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。也就是说如果我不按规范来也是可以的。只要服务端支持，我们可以在 URL 上写参数，然后方法使用 POST；也可以在 Body 写参数，然后方法使用 GET。</p>
<p>网上有几种说法，比如：</p>
<h3 id="POST-方法比-GET-方法安全？"><a href="#POST-方法比-GET-方法安全？" class="headerlink" title="POST 方法比 GET 方法安全？"></a>POST 方法比 GET 方法安全？</h3><p>按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是 HTTPS。</p>
<h3 id="GET方法有长度限制？"><a href="#GET方法有长度限制？" class="headerlink" title="GET方法有长度限制？"></a>GET方法有长度限制？</h3><p>网上有些文章提到GET方法有长度限制，但是HTTP协议中对URL和Body的长度并没有限制，对URL的限制大多是浏览器和服务器的原因。</p>
<h3 id="POST-方法会产生两个TCP数据包？"><a href="#POST-方法会产生两个TCP数据包？" class="headerlink" title="POST 方法会产生两个TCP数据包？"></a>POST 方法会产生两个TCP数据包？</h3><p>有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。</p>
<p>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><p><strong>不要混淆 session 和 session 实现。</strong></p>
<p>本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。</p>
<p> 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。</p>
<p>而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。</p>
<p>所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。</p>
<p>作者：欲三更</p>
<p>链接：<a href="https://www.zhihu.com/question/19786827/answer/84540780" target="_blank" rel="noopener">https://www.zhihu.com/question/19786827/answer/84540780</a></p>
<p>来源：知乎</p>
<h2 id="http-1-1缓存控制策略"><a href="#http-1-1缓存控制策略" class="headerlink" title="http 1.1缓存控制策略"></a>http 1.1缓存控制策略</h2><p>浏览器缓存分为强缓存和协商缓存。浏览器加载一个页面的简单流程如下：</p>
<ol>
<li>浏览器先根据这个资源的http头信息来判断是否命中<strong>强缓存</strong>。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。</li>
<li>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。<strong>服务器来判断浏览器本地缓存是否失效</strong>。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。</li>
<li>如果未命中<strong>协商缓存</strong>，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。</li>
</ol>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>命中强缓存时</strong>，浏览器并不会将请求发送给服务器。<strong>在Chrome的开发者工具中看到http的返回码是200(OK)。</strong></p>
<p><strong>强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</strong></p>
<p><strong>Cache-Control：</strong>Cache-Control是一个相对时间，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</p>
<ol>
<li><strong>max-age</strong> 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天。在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</li>
<li><strong>s-maxage</strong> 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。</li>
<li><strong>public</strong> 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。</li>
<li><strong>private</strong> 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。</li>
<li><strong>no-cache</strong> 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。</li>
<li><strong>no-store</strong> 禁止缓存，每次请求都要向服务器重新获取数据。</li>
<li><strong>must-revalidate</strong>指定如果页面是过期的，则去服务器进行获取。这个指令并不常用。</li>
</ol>
<p><strong>Expires：</strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p>Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，<strong>同时启用的时候Cache-Control优先级高。</strong></p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</p>
<p><strong>Last-Modify/If-Modify-Since：</strong> <strong>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，</strong>Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。当<strong>浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，</strong>该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。<strong>如果命中缓存，则返回http 304，并且不会返回资源内容，并且不会返回Last-Modify。</strong>由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。</p>
<p><strong>ETag/If-None-Match：</strong>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>
<h2 id="http-1-1线头阻塞"><a href="#http-1-1线头阻塞" class="headerlink" title="http 1.1线头阻塞"></a>http 1.1线头阻塞</h2><ul>
<li>HTTP1.0中，发送一次请求时，需要<strong>等待服务端响应了</strong>才可以继续发送请求。</li>
<li>在HTTP1.1中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照<strong>响应的顺序</strong>来一一接收</li>
<li>所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现<strong>阻塞</strong>的情况。从专业的名词上说这种情况，叫做<strong>线头阻塞</strong>（Head of line blocking）简称：HOLB</li>
</ul>
<h2 id="TraceRoute的原理"><a href="#TraceRoute的原理" class="headerlink" title="TraceRoute的原理"></a>TraceRoute的原理</h2><p>通过发送发送一系列TTL从1递增的包给目标主机来实现的。</p>
<h2 id="在浏览器中输入一个URL到显示页面的全过程"><a href="#在浏览器中输入一个URL到显示页面的全过程" class="headerlink" title="在浏览器中输入一个URL到显示页面的全过程"></a>在浏览器中输入一个URL到显示页面的全过程</h2><p>假定输入的是<code>www.baidu.com</code>。</p>
<ol>
<li>输入一个网址意味着浏览器要向百度发送一个数据包。而发送数据包需要知道对方的IP地址，我们这里只知道网址而不知道IP地址，因此需要进行域名查找。这时会用到应用层的DNS协议，它用来查找一个域名对应的IP地址。DNS查找的过程如下：<ul>
<li>浏览器首先检查缓存中有没有这个域名对应的IP地址，如果缓存中有，这个解析过程就结束，没有就继续在操作系统的缓存中查找是否有对应的条目，没有的话进入下一步；</li>
<li>如果在本机无法完成域名的解析，接下来就要到远程的域名解析服务器（DNS服务器）中取查找了，首先根据设置的DNS地址到本地区的DNS服务器（LDNS）中查找，如果LDNS中仍然没有命中，那么LDNS会往根域名服务器中查找，根域名服务器返回一个主域名服务器地址（gTLDServer），gTLD是国际顶级域名服务器。LDNS再像这个gTLD服务器查询并缓存返回结果，然后向用户返回结果。</li>
</ul>
</li>
<li>这样我们就得到了百度的IP地址。接下来在应用层中采用HTTP协议，将请求封装为HTTP数据包；然后将HTTP数据包封装到一个TCP数据包中，并且设置好端口号和IP地址发给数据链路层（TCP有三次握手）。</li>
<li>数据链路层光知道IP地址并不够，还得知道硬件地址。因此需要ARP协议来实现IP地址到硬件地址的映射。ARP协议工作流程见上文。</li>
<li>知道了硬件物理地址之后，网卡就能将数据包发往服务器了，接着服务器段从链路层开始解析数据包，一直解析到应用层HTTP，解析完成后处理请求，发送响应给客户端。同样需要上面的传输过程。</li>
</ol>
<h1 id="Unix-Linux-操作系统与开发环境"><a href="#Unix-Linux-操作系统与开发环境" class="headerlink" title="Unix/Linux 操作系统与开发环境"></a>Unix/Linux 操作系统与开发环境</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>五种状态：</p>
<ol>
<li>创建</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
<li>退出</li>
</ol>
<p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。理论上说Linux内核是没有线程这个概念的，只有内核调度实体(Kernal Scheduling Entry， KSE)这个概念。Linux的线程本质上是一种轻量级的进程，是通过clone系统调用来创建的。在内核中，线程与进程都是用结构体task_struct来表示的，在内核调度上并没有什么区别。</p>
<p>线程和进程各自有什么区别和优劣呢？</p>
<ul>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li>
<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>
<li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li>
<li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>
</ul>
<h2 id="操作系统是如何切换进程和线程的？为什么进程切换比线程切换开销大？"><a href="#操作系统是如何切换进程和线程的？为什么进程切换比线程切换开销大？" class="headerlink" title="操作系统是如何切换进程和线程的？为什么进程切换比线程切换开销大？"></a>操作系统是如何切换进程和线程的？为什么进程切换比线程切换开销大？</h2><p>进程切换：切换CPU中的上下文寄存器，切换地址空间，还要刷新TLB，一旦TLB刷新，进程的地址翻译过程可能会非常的慢。</p>
<p>线程切换：只需要切换寄存器上下文即可，地址空间，TLB等都无需变化。</p>
<h2 id="死锁的条件及解决办法"><a href="#死锁的条件及解决办法" class="headerlink" title="死锁的条件及解决办法"></a>死锁的条件及解决办法</h2><ul>
<li>死锁的条件<br>必须同时存在以下的四个条件才能发生死锁。<ol>
<li>互斥条件<br>即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。</li>
<li>不可抢占条件。<br>进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。</li>
<li>占有且申请条件。<br>进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。</li>
<li>循环等待条件<br>存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。</li>
</ol>
</li>
<li>死锁的预防<br>死锁的预防是保证系统不进入死锁状态的一种策略。</li>
</ul>
<ol>
<li>破坏互斥条件<br>有些资源不能被共享。—没用</li>
<li>破坏不可抢占条件。<br>可抢占式，即要求申请失败的进程释放自己占有的资源给别人用，降低系统性能。</li>
<li>破坏占有且申请条件。<br>直接申请自己所需要的所有资源。—1.不可预知自己需要什么资源  2.资源利用率低，长期占有自己可能不用的资源。</li>
<li>破坏循环等待条件<br>资源分类、编号，按序申请。 —·1.编号可能是困难的，维护相应的序列是困难的</li>
</ol>
<ul>
<li>死锁的避免<br>死锁的避免指的是不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。<br>银行家算法。当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li>
</ul>
<p>判定安全状态需要已分配资源、还需要的资源、可用资源、finish判定符</p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>理由：如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。</p>
<h2 id="大小端是什么，由什么决定"><a href="#大小端是什么，由什么决定" class="headerlink" title="大小端是什么，由什么决定"></a>大小端是什么，由什么决定</h2><ul>
<li>Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
</ul>
<p>互联网使用的网络字节顺序采用大端模式进行编址，而主机字节顺序根据处理器的不同而不同.</p>
<p>通过如下程序可以判断是否为大端（关键点在于判断超过一个字节的内容在内存中的存放顺序）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">char</span> b =  *(<span class="keyword">char</span> *)&amp;a;  <span class="comment">//通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分</span></span><br><span class="line">    <span class="keyword">if</span>( b == <span class="number">0x12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟内存是怎么实现的，要划分多少页，每页有多大？"><a href="#虚拟内存是怎么实现的，要划分多少页，每页有多大？" class="headerlink" title="虚拟内存是怎么实现的，要划分多少页，每页有多大？"></a>虚拟内存是怎么实现的，要划分多少页，每页有多大？</h2><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><strong>FIFO置换算法：</strong> 简单粗暴的一种置换算法，每次置换最早调入的页面。但是很明显，效率不高。</p>
<p><strong>最佳置换算法（MIN算法）：</strong> 将当前页面中在未来最长时间内不会被访问的页置换出去。但是MIN算法需要知道将来发生的事情，这是不可能的，所以这个算法也不现实。</p>
<p><strong>LRU算法：</strong> 选最近最长一段时间没有使用的页淘汰。算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。但是实现的代价较大。</p>
<p><strong>时钟算法clock：</strong> 页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p>
<h2 id="应用程序加载到内存的具体过程"><a href="#应用程序加载到内存的具体过程" class="headerlink" title="应用程序加载到内存的具体过程"></a>应用程序加载到内存的具体过程</h2><p>loader会启动，通过mmap系统调用将代码段和数据段映射到内存中，也就是分配虚拟内存。注意这个时候是不占用物理内存的，只有当程序需要读取这块内存的时候会发生缺页中断，然后会去请求调页。</p>
<h2 id="物理内存和虚拟内存的区别？为什么要用虚拟内存？"><a href="#物理内存和虚拟内存的区别？为什么要用虚拟内存？" class="headerlink" title="物理内存和虚拟内存的区别？为什么要用虚拟内存？"></a>物理内存和虚拟内存的区别？为什么要用虚拟内存？</h2><h2 id="Linux文件系统，Linux写入一个文件的过程中，这个文件被移动了，那怎么办？从linux的文件系统原理分析一下？"><a href="#Linux文件系统，Linux写入一个文件的过程中，这个文件被移动了，那怎么办？从linux的文件系统原理分析一下？" class="headerlink" title="Linux文件系统，Linux写入一个文件的过程中，这个文件被移动了，那怎么办？从linux的文件系统原理分析一下？"></a>Linux文件系统，Linux写入一个文件的过程中，这个文件被移动了，那怎么办？从linux的文件系统原理分析一下？</h2><h2 id="一个进程在内存中是不是连续的？"><a href="#一个进程在内存中是不是连续的？" class="headerlink" title="一个进程在内存中是不是连续的？"></a>一个进程在内存中是不是连续的？</h2><p>由于分页机制的存在一般是不连续的。但是在虚拟内存这一层面上来说是连续的。</p>
<h2 id="epoll和select区别"><a href="#epoll和select区别" class="headerlink" title="epoll和select区别"></a>epoll和select区别</h2><h2 id="linux系统怎么看系统资源状况"><a href="#linux系统怎么看系统资源状况" class="headerlink" title="linux系统怎么看系统资源状况"></a>linux系统怎么看系统资源状况</h2><p><code>top</code>、<code>free</code></p>
<h2 id="linux系统怎么看IO状况"><a href="#linux系统怎么看IO状况" class="headerlink" title="linux系统怎么看IO状况"></a>linux系统怎么看IO状况</h2><ul>
<li><p><code>top</code></p>
</li>
<li><p><code>iostat</code></p>
<p>通过<code>iostat</code>可以查看Linux系统IO是否存在瓶颈。</p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1553737185069.png" alt="1553737185069"></p>
<p>iostat 主要有三个操作项，options 操作项，interval指定统计时间间隔，count总共输出次数。</p>
<ul>
<li><p><code>-c</code>：用来查看cpu状态信息。</p>
</li>
<li><p><code>-d</code>：显示磁盘使用状态：</p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1553737633997.png" alt="1553737633997"></p>
<p>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。<br>kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。</p>
</li>
<li><p><code>-x</code>：输出更多详细信息：</p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1553737887469.png" alt="1553737887469"></p>
<p>rrqm/s：每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）；</p>
<p>wrqm/s：每秒这个设备相关的写入请求有多少被Merge了。</p>
<p>rsec/s：每秒读取的扇区数；wsec/：每秒写入的扇区数。</p>
<p>r/s：The number of read requests that were issued to the device per second</p>
<p>w/s：The number of write requests that were issued to the device per second；</p>
<p>await：每一个IO请求的处理的平均时间（单位是毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。</p>
<p>%util：在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）</p>
</li>
</ul>
<p>常见用法：<code>iostat -d -k 1 10</code>：查看TPS和吞吐量信息</p>
</li>
<li><p><code>free</code></p>
</li>
<li><p><code>vmstat</code></p>
<p><img src="/2019/03/27/C-后台开发面试题汇总/1553739179845.png" alt="1553739179845"></p>
<p>1、procs</p>
<p>r：表示运行和等待CPU时间片的进程数（就是说多少个进程真的分配到CPU），这个值如果长期大于系统CPU个数，说明CPU不足，需要增加CPU</p>
<p>b：表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</p>
<p>2、memory</p>
<p>交换：表示切换到内存交换区的内存大小，即虚拟内存已使用的大小（单位KB），如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。</p>
<p>空闲：表示当前空闲的物理内存</p>
<p>缓冲：表示baffers cached内存大小，也就是缓冲大小，一般对块设备的读写才需要缓冲</p>
<p>缓存：表示page cached的内存大小，也就是缓存大小，一般作为文件系统进行缓冲，频繁访问的文件都会被缓存，<strong>如果cache值非常大说明缓存文件比较多，如果此时io中的bi比较小，说明文件系统效率比较好</strong></p>
<p>3、swap</p>
<p>si：表示有磁盘调入内存，也就是内存进入内存交换区的内存大小；通俗的讲就是 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。</p>
<p>so：表示由内存进入磁盘，也就是由内存交换区进入内存的内存大小。</p>
<p><strong>注意：一般情况下si、so的值都为0，如果si、so的值长期不为0，则说明系统内存不足，需要增加系统内存</strong></p>
<p>4、io</p>
<p>bi：表示由块设备读入数据的总量，即读磁盘，单位kb/s</p>
<p>bo：表示写到块设备数据的总量，即写磁盘，单位kb/s</p>
<p><strong>注意：如果bi+bo的值过大，且wa值较大，则表示系统磁盘IO瓶颈</strong></p>
<p>5、system</p>
<p>in：表示某一时间间隔内观测到的每秒设备终端数</p>
<p>cs：表示每秒产生的 上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p>
<p><strong>注意：这两个值越大，则由内核消耗的CPU就越多</strong></p>
<p>6、CPU</p>
<p>us：表示用户进程消耗的CPU时间百分比，us值越高，说明用户进程消耗CPU时间越多，如果长期大于50%，则需要考虑优化程序或者算法</p>
<p>sy：表示系统内核进程消耗的CPU时间百分比，<strong>一般来说us+sy应该小于80%，如果大于80%，说明可能存在CPU瓶颈</strong></p>
<p>id：表示CPU处在空间状态的时间百分比</p>
<p>wa：表示IP等待所占用的CPU时间百分比，wa值越高，说明I/O等待越严重，根据经验wa的参考值为20%，如果超过20%，说明I/O等待严重，引起I/O等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者监控器的贷款瓶颈（主要是块操作）造成的</p>
<p>综上所述，如果评估CPU，需要重点关注procs项的r列值和CPU想的us、sy、wa列的值</p>
<p><strong>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数</strong>，一般不需指定额外的参数。</p>
</li>
</ul>
<h2 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h2><p>参考<a href="https://www.zhihu.com/question/20122137" target="_blank" rel="noopener">这里</a>。推荐<a href="https://www.zhihu.com/people/jing-hai-ting-feng" target="_blank" rel="noopener">@静海听风</a>的回答。</p>
<h2 id="Linux进程间通讯机制及应用场景"><a href="#Linux进程间通讯机制及应用场景" class="headerlink" title="Linux进程间通讯机制及应用场景"></a>Linux进程间通讯机制及应用场景</h2><p>管道、信号、消息队列、共享内存、socket、信号量</p>
<h2 id="线程同步机制及应用场景"><a href="#线程同步机制及应用场景" class="headerlink" title="线程同步机制及应用场景"></a>线程同步机制及应用场景</h2><h2 id="ps命令详解"><a href="#ps命令详解" class="headerlink" title="ps命令详解"></a><code>ps</code>命令详解</h2><h2 id="多线程二分查找，用什么锁"><a href="#多线程二分查找，用什么锁" class="headerlink" title="多线程二分查找，用什么锁"></a>多线程二分查找，用什么锁</h2><h2 id="操作系统如何让线程Sleep？"><a href="#操作系统如何让线程Sleep？" class="headerlink" title="操作系统如何让线程Sleep？"></a>操作系统如何让线程Sleep？</h2><h2 id="mutex如何实现？"><a href="#mutex如何实现？" class="headerlink" title="mutex如何实现？"></a>mutex如何实现？</h2><h2 id="fopen调用的过程？"><a href="#fopen调用的过程？" class="headerlink" title="fopen调用的过程？"></a>fopen调用的过程？</h2><h2 id="syscall指令"><a href="#syscall指令" class="headerlink" title="syscall指令"></a>syscall指令</h2><p>在Linux中，用户可以通过两种方式来执行系统调用，一种是通过C库函数，另外一种方式是使用<code>syscall()</code>函数。</p>
<h2 id="Linux文件系统？打开读写一个文件的全过程？"><a href="#Linux文件系统？打开读写一个文件的全过程？" class="headerlink" title="Linux文件系统？打开读写一个文件的全过程？"></a>Linux文件系统？打开读写一个文件的全过程？</h2><p>参考<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">这里</a>。</p>
<p>重点：移动文件或重命名文件，只是改变文件名，不影响inode号码。</p>
<h2 id="同步异步、阻塞非阻塞的概念"><a href="#同步异步、阻塞非阻塞的概念" class="headerlink" title="同步异步、阻塞非阻塞的概念"></a>同步异步、阻塞非阻塞的概念</h2><h2 id="Reactor模式与Proactor模式"><a href="#Reactor模式与Proactor模式" class="headerlink" title="Reactor模式与Proactor模式"></a>Reactor模式与Proactor模式</h2><p>Reactor模式：同步的事件循环+非阻塞IO</p>
<p>Proactor模式：</p>
<p>Reactor模式和Proactor模式的主要区别:</p>
<ol>
<li>Reactor实现同步I/O多路分发，Proactor实现异步I/O分发。</li>
</ol>
<p>　　如果只是处理网络I/O单线程的Reactor尚可处理，但如果涉及到文件I/O，单线程的Reactor可能被文件I/O阻塞而导致其他事件无法被分发。所以涉及到文件I/O最好还是使用Proactor模式，或者用多线程模拟实现异步I/O的方式。</p>
<ol>
<li>Reactor模式注册的是文件描述符的就绪事件，而Proactor模式注册的是完成事件。</li>
</ol>
<p>　　即Reactor模式有事件发生的时候要判断是读事件还是写事件，然后用再调用系统调用(read/write等)将数据从内核中拷贝到用户数据区继续其他业务处理。而Proactor模式一般使用的是操作系统的异步I/O接口，发起异步调用（用户提供数据缓冲区）之后操作系统将在内核态完成I/O并拷贝数据到用户提供的缓冲区中，完成事件到达之后，用户只需要实现自己后续的业务处理即可。</p>
<ol>
<li>主动和被动</li>
</ol>
<p>　　Reactor模式是一种被动的处理，即有事件发生时被动处理。而Proator模式则是主动发起异步调用，然后循环检测完成事件。</p>
<h2 id="如何实现原子操作"><a href="#如何实现原子操作" class="headerlink" title="如何实现原子操作"></a>如何实现原子操作</h2><h2 id="Linux进程调度模型"><a href="#Linux进程调度模型" class="headerlink" title="Linux进程调度模型"></a>Linux进程调度模型</h2><h2 id="Linux中条件变量使用时带锁的原因"><a href="#Linux中条件变量使用时带锁的原因" class="headerlink" title="Linux中条件变量使用时带锁的原因"></a>Linux中条件变量使用时带锁的原因</h2><h2 id="动态库与静态库的区别"><a href="#动态库与静态库的区别" class="headerlink" title="动态库与静态库的区别"></a>动态库与静态库的区别</h2><h2 id="用户态与内核态的区别"><a href="#用户态与内核态的区别" class="headerlink" title="用户态与内核态的区别"></a>用户态与内核态的区别</h2><h2 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h2><h2 id="操作系统进程调度模型"><a href="#操作系统进程调度模型" class="headerlink" title="操作系统进程调度模型"></a>操作系统进程调度模型</h2><h2 id="操作系统的段页式内存管理"><a href="#操作系统的段页式内存管理" class="headerlink" title="操作系统的段页式内存管理"></a>操作系统的段页式内存管理</h2><h2 id="coredump调试方法"><a href="#coredump调试方法" class="headerlink" title="coredump调试方法"></a>coredump调试方法</h2><h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="1-给定三角形ABC和一点P-x-y-，判断点P是否在ABC内"><a href="#1-给定三角形ABC和一点P-x-y-，判断点P是否在ABC内" class="headerlink" title="1. 给定三角形ABC和一点P(x,y)，判断点P是否在ABC内"></a>1. 给定三角形ABC和一点P(x,y)，判断点P是否在ABC内</h2><p>解法一：</p>
<p>连接点P和三角形的三个顶点得到三条线段PA，PB和PC，求出这三条线段与三角形各边的夹角，如果所有夹角之和为180度，那么点P在三角形内，否则不在，此法直观，但效率低下。</p>
<p>解法二：</p>
<p>假设点P位于三角形内，会有这样一个规律，当我们沿着ABCA的方向在三条边上行走时，你会发现点P始终位于边AB，BC和CA的右侧。我们就利用这一点，但是如何判断一个点在线段的左侧还是右侧呢？我们可以从另一个角度来思考，当选定线段AB时，点C位于AB的右侧，同理选定BC时，点A位于BC的右侧，最后选定CA时，点B位于CA的右侧，所以当选择某一条边时，我们只需验证点P与该边所对的点在同一侧即可。问题又来了，如何判断两个点在某条线段的同一侧呢？可以通过叉积来实现，连接AP，将AP和AB做叉积，再将AC和AB做叉积，<strong>如果两个叉积的结果向量方向一致，那么两个点在同一侧</strong>。另外，判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。</p>
<h2 id="2-判断一个数是否为2的倍数，判断一个数的二进制表示中有几个1"><a href="#2-判断一个数是否为2的倍数，判断一个数的二进制表示中有几个1" class="headerlink" title="2. 判断一个数是否为2的倍数，判断一个数的二进制表示中有几个1"></a>2. 判断一个数是否为2的倍数，判断一个数的二进制表示中有几个1</h2><p>要判断一个数是否为2的倍数只需要判断该数的二进制表示的最后一位是否为1即可，如果为1则为奇数，否则为偶数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">even</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(num &amp; <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要判断一个数的二进制表示中有几个1，将一个整数减去1然后与这个整数做与运算，结果恰好将最右边的1变为0，然后重复这个与操作，例如，n = 1001，那么 n&amp;= n-1 之后 n变为1000，再做一次 n&amp;=n-1，n 变为0，总共循环了两次，1的个数就是2个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        num &amp;= num<span class="number">-1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-线段树的实现"><a href="#3-线段树的实现" class="headerlink" title="3. 线段树的实现"></a>3. 线段树的实现</h2><h2 id="4-线段树用数组的优缺点，用指针的优缺点"><a href="#4-线段树用数组的优缺点，用指针的优缺点" class="headerlink" title="4. 线段树用数组的优缺点，用指针的优缺点"></a>4. 线段树用数组的优缺点，用指针的优缺点</h2><h2 id="5-实现哈希表"><a href="#5-实现哈希表" class="headerlink" title="5. 实现哈希表"></a>5. 实现哈希表</h2><h2 id="6-实现LRU"><a href="#6-实现LRU" class="headerlink" title="6. 实现LRU"></a>6. 实现LRU</h2><h2 id="7-二叉树的先序、中序、后序遍历，递归与非递归实现"><a href="#7-二叉树的先序、中序、后序遍历，递归与非递归实现" class="headerlink" title="7. 二叉树的先序、中序、后序遍历，递归与非递归实现"></a>7. 二叉树的先序、中序、后序遍历，递归与非递归实现</h2><h2 id="8-判断链表是否有环"><a href="#8-判断链表是否有环" class="headerlink" title="8. 判断链表是否有环"></a>8. 判断链表是否有环</h2><h2 id="9-判断链表是否相交"><a href="#9-判断链表是否相交" class="headerlink" title="9. 判断链表是否相交"></a>9. 判断链表是否相交</h2><h2 id="10-有序循环数组查找最小值"><a href="#10-有序循环数组查找最小值" class="headerlink" title="10. 有序循环数组查找最小值"></a>10. 有序循环数组查找最小值</h2><p>例如[4,5,1,2,3]找到1。</p>
<h2 id="11-实现atoi"><a href="#11-实现atoi" class="headerlink" title="11. 实现atoi"></a>11. 实现<code>atoi</code></h2><h2 id="12-AVL数"><a href="#12-AVL数" class="headerlink" title="12. AVL数"></a>12. AVL数</h2><h2 id="13-红黑树"><a href="#13-红黑树" class="headerlink" title="13. 红黑树"></a>13. 红黑树</h2><h2 id="14-B树和B-树"><a href="#14-B树和B-树" class="headerlink" title="14. B树和B+树"></a>14. B树和B+树</h2><h2 id="15-平面n个点，找穿过点最多的直线"><a href="#15-平面n个点，找穿过点最多的直线" class="headerlink" title="15. 平面n个点，找穿过点最多的直线"></a>15. 平面n个点，找穿过点最多的直线</h2><h2 id="16-外部排序"><a href="#16-外部排序" class="headerlink" title="16. 外部排序"></a>16. 外部排序</h2><h2 id="建堆的过程"><a href="#建堆的过程" class="headerlink" title="建堆的过程"></a>建堆的过程</h2><p>参见<a href="[http://imty.site/2018/12/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95--%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F,%E5%A0%86%E6%8E%92%E5%BA%8F,%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/#more](http://imty.site/2018/12/08/排序算法--快速排序,堆排序,计数排序/#more">这里</a>)。</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
            <a href="/tags/计算机网络/" rel="tag"># 计算机网络</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/23/LeetCode-378-有序矩阵中第k小的元素/" rel="next" title="LeetCode-378-有序矩阵中第k小的元素">
                <i class="fa fa-chevron-left"></i> LeetCode-378-有序矩阵中第k小的元素
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/27/C-合成默认构造函数与拷贝构造函数的真相/" rel="prev" title="C++合成默认构造函数与拷贝构造函数的真相">
                C++合成默认构造函数与拷贝构造函数的真相 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="EnochTang">
            
              <p class="site-author-name" itemprop="name">EnochTang</p>
              <p class="site-description motion-element" itemprop="description">个人小站</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/iLoveTangY" title="GitHub &rarr; https://github.com/iLoveTangY" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/ytang007@163.com" title="E-Mail &rarr; ytang007@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C-语言基础"><span class="nav-number">1.</span> <span class="nav-text">C/C++ 语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-变量内存布局"><span class="nav-number">1.1.</span> <span class="nav-text">C++变量内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字的作用"><span class="nav-number">1.2.</span> <span class="nav-text">static关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四种cast转换"><span class="nav-number">1.3.</span> <span class="nav-text">四种cast转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与引用的区别与联系"><span class="nav-number">1.4.</span> <span class="nav-text">指针与引用的区别与联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11的三种智能指针"><span class="nav-number">1.5.</span> <span class="nav-text">C++ 11的三种智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-里map和set为什么采用红黑树不采用AVL-Tree？"><span class="nav-number">1.6.</span> <span class="nav-text">C++ 里map和set为什么采用红黑树不采用AVL Tree？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-面向对象三大特性"><span class="nav-number">1.7.</span> <span class="nav-text">C++ 面向对象三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数与纯虚函数"><span class="nav-number">1.8.</span> <span class="nav-text">虚函数与纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const关键字的作用"><span class="nav-number">1.9.</span> <span class="nav-text">const关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数指针和函数对象的区别"><span class="nav-number">1.10.</span> <span class="nav-text">函数指针和函数对象的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcpy和memmove的区别以及实现，strncpy的实现"><span class="nav-number">1.11.</span> <span class="nav-text">memcpy和memmove的区别以及实现，strncpy的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何限制一个类对象只在栈（堆）上分配空间？"><span class="nav-number">1.12.</span> <span class="nav-text">如何限制一个类对象只在栈（堆）上分配空间？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-实现单例模式"><span class="nav-number">1.13.</span> <span class="nav-text">C++实现单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量指针与指针常量"><span class="nav-number">1.14.</span> <span class="nav-text">常量指针与指针常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#右值引用"><span class="nav-number">1.15.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-有虚函数时类对象内存布局"><span class="nav-number">1.16.</span> <span class="nav-text">C++有虚函数时类对象内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个C-程序执行main函数前和执行完main函数后会发生什么"><span class="nav-number">1.17.</span> <span class="nav-text">一个C++程序执行main函数前和执行完main函数后会发生什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP基础"><span class="nav-number">2.1.</span> <span class="nav-text">TCP基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SYN泛洪攻击"><span class="nav-number">2.2.</span> <span class="nav-text">SYN泛洪攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP和UDP的区别及应用场景"><span class="nav-number">2.3.</span> <span class="nav-text">TCP和UDP的区别及应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP如何实现可靠传输"><span class="nav-number">2.4.</span> <span class="nav-text">UDP如何实现可靠传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http协议1-0-1-1-和-2有什么异同？"><span class="nav-number">2.5.</span> <span class="nav-text">http协议1.0 1.1 和 2有什么异同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用http协议请求文件中的某一段该如何处理，请求的偏移量超过了文件大小会返回什么"><span class="nav-number">2.6.</span> <span class="nav-text">使用http协议请求文件中的某一段该如何处理，请求的偏移量超过了文件大小会返回什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS协议"><span class="nav-number">2.7.</span> <span class="nav-text">DNS协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ip包在路由器的传播过程"><span class="nav-number">2.8.</span> <span class="nav-text">ip包在路由器的传播过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP协议"><span class="nav-number">2.9.</span> <span class="nav-text">ARP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP黏包问题"><span class="nav-number">2.10.</span> <span class="nav-text">TCP黏包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https与http"><span class="nav-number">2.11.</span> <span class="nav-text">https与http</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET与POST的区别"><span class="nav-number">2.12.</span> <span class="nav-text">GET与POST的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#POST-方法比-GET-方法安全？"><span class="nav-number">2.12.1.</span> <span class="nav-text">POST 方法比 GET 方法安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET方法有长度限制？"><span class="nav-number">2.12.2.</span> <span class="nav-text">GET方法有长度限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POST-方法会产生两个TCP数据包？"><span class="nav-number">2.12.3.</span> <span class="nav-text">POST 方法会产生两个TCP数据包？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie和session的区别"><span class="nav-number">2.13.</span> <span class="nav-text">cookie和session的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-1-1缓存控制策略"><span class="nav-number">2.14.</span> <span class="nav-text">http 1.1缓存控制策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强缓存"><span class="nav-number">2.14.1.</span> <span class="nav-text">强缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协商缓存"><span class="nav-number">2.14.2.</span> <span class="nav-text">协商缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-1-1线头阻塞"><span class="nav-number">2.15.</span> <span class="nav-text">http 1.1线头阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TraceRoute的原理"><span class="nav-number">2.16.</span> <span class="nav-text">TraceRoute的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在浏览器中输入一个URL到显示页面的全过程"><span class="nav-number">2.17.</span> <span class="nav-text">在浏览器中输入一个URL到显示页面的全过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unix-Linux-操作系统与开发环境"><span class="nav-number">3.</span> <span class="nav-text">Unix/Linux 操作系统与开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程的区别"><span class="nav-number">3.1.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统是如何切换进程和线程的？为什么进程切换比线程切换开销大？"><span class="nav-number">3.2.</span> <span class="nav-text">操作系统是如何切换进程和线程的？为什么进程切换比线程切换开销大？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的条件及解决办法"><span class="nav-number">3.3.</span> <span class="nav-text">死锁的条件及解决办法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节对齐"><span class="nav-number">3.4.</span> <span class="nav-text">字节对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大小端是什么，由什么决定"><span class="nav-number">3.5.</span> <span class="nav-text">大小端是什么，由什么决定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟内存是怎么实现的，要划分多少页，每页有多大？"><span class="nav-number">3.6.</span> <span class="nav-text">虚拟内存是怎么实现的，要划分多少页，每页有多大？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面置换算法"><span class="nav-number">3.7.</span> <span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用程序加载到内存的具体过程"><span class="nav-number">3.8.</span> <span class="nav-text">应用程序加载到内存的具体过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理内存和虚拟内存的区别？为什么要用虚拟内存？"><span class="nav-number">3.9.</span> <span class="nav-text">物理内存和虚拟内存的区别？为什么要用虚拟内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux文件系统，Linux写入一个文件的过程中，这个文件被移动了，那怎么办？从linux的文件系统原理分析一下？"><span class="nav-number">3.10.</span> <span class="nav-text">Linux文件系统，Linux写入一个文件的过程中，这个文件被移动了，那怎么办？从linux的文件系统原理分析一下？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个进程在内存中是不是连续的？"><span class="nav-number">3.11.</span> <span class="nav-text">一个进程在内存中是不是连续的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll和select区别"><span class="nav-number">3.12.</span> <span class="nav-text">epoll和select区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux系统怎么看系统资源状况"><span class="nav-number">3.13.</span> <span class="nav-text">linux系统怎么看系统资源状况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux系统怎么看IO状况"><span class="nav-number">3.14.</span> <span class="nav-text">linux系统怎么看IO状况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll实现原理"><span class="nav-number">3.15.</span> <span class="nav-text">epoll实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux进程间通讯机制及应用场景"><span class="nav-number">3.16.</span> <span class="nav-text">Linux进程间通讯机制及应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步机制及应用场景"><span class="nav-number">3.17.</span> <span class="nav-text">线程同步机制及应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ps命令详解"><span class="nav-number">3.18.</span> <span class="nav-text">ps命令详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程二分查找，用什么锁"><span class="nav-number">3.19.</span> <span class="nav-text">多线程二分查找，用什么锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统如何让线程Sleep？"><span class="nav-number">3.20.</span> <span class="nav-text">操作系统如何让线程Sleep？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutex如何实现？"><span class="nav-number">3.21.</span> <span class="nav-text">mutex如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fopen调用的过程？"><span class="nav-number">3.22.</span> <span class="nav-text">fopen调用的过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#syscall指令"><span class="nav-number">3.23.</span> <span class="nav-text">syscall指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux文件系统？打开读写一个文件的全过程？"><span class="nav-number">3.24.</span> <span class="nav-text">Linux文件系统？打开读写一个文件的全过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步异步、阻塞非阻塞的概念"><span class="nav-number">3.25.</span> <span class="nav-text">同步异步、阻塞非阻塞的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor模式与Proactor模式"><span class="nav-number">3.26.</span> <span class="nav-text">Reactor模式与Proactor模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现原子操作"><span class="nav-number">3.27.</span> <span class="nav-text">如何实现原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux进程调度模型"><span class="nav-number">3.28.</span> <span class="nav-text">Linux进程调度模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux中条件变量使用时带锁的原因"><span class="nav-number">3.29.</span> <span class="nav-text">Linux中条件变量使用时带锁的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态库与静态库的区别"><span class="nav-number">3.30.</span> <span class="nav-text">动态库与静态库的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户态与内核态的区别"><span class="nav-number">3.31.</span> <span class="nav-text">用户态与内核态的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#proc文件系统"><span class="nav-number">3.32.</span> <span class="nav-text">proc文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统进程调度模型"><span class="nav-number">3.33.</span> <span class="nav-text">操作系统进程调度模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的段页式内存管理"><span class="nav-number">3.34.</span> <span class="nav-text">操作系统的段页式内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#coredump调试方法"><span class="nav-number">3.35.</span> <span class="nav-text">coredump调试方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法与数据结构"><span class="nav-number">4.</span> <span class="nav-text">算法与数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-给定三角形ABC和一点P-x-y-，判断点P是否在ABC内"><span class="nav-number">4.1.</span> <span class="nav-text">1. 给定三角形ABC和一点P(x,y)，判断点P是否在ABC内</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-判断一个数是否为2的倍数，判断一个数的二进制表示中有几个1"><span class="nav-number">4.2.</span> <span class="nav-text">2. 判断一个数是否为2的倍数，判断一个数的二进制表示中有几个1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-线段树的实现"><span class="nav-number">4.3.</span> <span class="nav-text">3. 线段树的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-线段树用数组的优缺点，用指针的优缺点"><span class="nav-number">4.4.</span> <span class="nav-text">4. 线段树用数组的优缺点，用指针的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-实现哈希表"><span class="nav-number">4.5.</span> <span class="nav-text">5. 实现哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-实现LRU"><span class="nav-number">4.6.</span> <span class="nav-text">6. 实现LRU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-二叉树的先序、中序、后序遍历，递归与非递归实现"><span class="nav-number">4.7.</span> <span class="nav-text">7. 二叉树的先序、中序、后序遍历，递归与非递归实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-判断链表是否有环"><span class="nav-number">4.8.</span> <span class="nav-text">8. 判断链表是否有环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-判断链表是否相交"><span class="nav-number">4.9.</span> <span class="nav-text">9. 判断链表是否相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-有序循环数组查找最小值"><span class="nav-number">4.10.</span> <span class="nav-text">10. 有序循环数组查找最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-实现atoi"><span class="nav-number">4.11.</span> <span class="nav-text">11. 实现atoi</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-AVL数"><span class="nav-number">4.12.</span> <span class="nav-text">12. AVL数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-红黑树"><span class="nav-number">4.13.</span> <span class="nav-text">13. 红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-B树和B-树"><span class="nav-number">4.14.</span> <span class="nav-text">14. B树和B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-平面n个点，找穿过点最多的直线"><span class="nav-number">4.15.</span> <span class="nav-text">15. 平面n个点，找穿过点最多的直线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-外部排序"><span class="nav-number">4.16.</span> <span class="nav-text">16. 外部排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建堆的过程"><span class="nav-number">4.17.</span> <span class="nav-text">建堆的过程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EnochTang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'pzkWbX0BctrHGXtuYk89bhtE-gzGzoHsz',
        appKey: 'm8j90AEPPX5XX9lYPTH2CkkY',
        placeholder: '真的不说点什么吗？n(*≧▽≦*)n',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "pzkWbX0BctrHGXtuYk89bhtE-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "pzkWbX0BctrHGXtuYk89bhtE-gzGzoHsz",
                'X-LC-Key': "m8j90AEPPX5XX9lYPTH2CkkY",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

  

</body>
</html>
